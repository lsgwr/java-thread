# 第15章 服务降级与服务熔断思路

## 服务降级

服务压力剧增的时候根据当前的业务情况及流量对一些服务和页面有策略的降级，以此缓解服务器的压力，以`保证核心任务的进行`。同时保证部分甚至大部分任务客户能得到正确的响应。也就是当前的请求处理不了了或者出错了，给一个默认的返回。

## 服务熔断

在股票市场，熔断这个词大家都不陌生，是指当股指波幅达到某个点后，交易所为控制风险采取的暂停交易措施。相应的，服务熔断一般是指软件系统中，由于某些原因使得服务出现了过载现象，为防止造成整个系统故障，从而采用的一种保护措施，所以很多地方把熔断亦称为`过载保护`

## 降级分类

+ 降级按照`是否自动化`可分为：`自动开关降级`和`人工开关降级`
+ 降级按照`功能`可分为：`读服务降级`、`写服务降级`
+ 降级按照处于的`系统层次`可分为：`多级降级`

## 自动降级分类

+ （1）超时降级
  > 主要配置好超时时间和超时重试次数和机制，并使用异步机制探测回复情况
+ （2）失败次数降级
  > 主要是一些不稳定的api，当失败调用次数达到一定阀值自动降级，同样要使用异步机制探测回复情况
+ （3）故障降级
  > 比如要调用的远程服务挂掉了（网络故障、DNS故障、http服务返回错误的状态码、rpc服务抛出异常），则可以直接降级。降级后的处理方案有：默认值（比如库存服务挂了，返回默认现货）、兜底数据（比如广告挂了，返回提前准备好的一些静态页面）、缓存（之前暂存的一些缓存数据）
+ （4）限流降级
  > 当我们去秒杀或者抢购一些限购商品时，此时可能会因为访问量太大而导致系统崩溃，此时开发者会使用限流来进行限制访问量，当达到限流阀值，后续请求会被降级；降级后的处理方案可以是：排队页面（将用户导流到排队页面等一会重试）、无货（直接告知用户没货了）、错误页（如活动太火爆了，稍后重试）。

## 服务熔断和服务降级比较

### 相同

+ 1.目的很一致，都是从可用性可靠性着想，为防止系统的整体缓慢甚至崩溃，采用的技术手段；
+ 2.最终表现类似，对于两者来说，最终让用户体验到的是某些功能暂时不可达或不可用；
+ 3.粒度一般都是服务级别，当然，业界也有不少更细粒度的做法，比如做到数据持久层（允许查询，不允许增删改）；
+ 4.自治性要求很高，熔断模式一般都是服务基于策略的自动触发，降级虽说可人工干预，但在微服务架构下，完全靠人显然不可能，开关预置、配置中心都是必要手段；

### 不同

+ 触发原因不太一样，服务熔断一般是某个服务（下游服务）故障引起，而服务降级一般是从整体负荷考虑；
+ 管理目标的层次不太一样，熔断其实是一个框架级的处理，每个微服务都需要（无层级之分），而降级一般需要对业务有层级之分（比如降级一般是从最外围服务开始）
+ 实现方式不太一样

## 服务降级要考虑的问题

+ 1.核心和非核心服务
+ 2.是否支持降级，降级策略
+ 3.业务放通的场景，策略

## Hystrix

Hystrix，该库旨在通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备拥有`回退机制`和`断路器`功能的`线程和信号隔离`，请求缓存和请求打包（request collapsing，即自动批处理，译者注），以及监控和配置等功能。

### Hystrix能做什么？

+ 1.在通过第三方客户端访问（通常是通过网络）依赖服务出现高延迟或者失败时，为系统提供保护和控制
+ 2.在分布式系统中防止级联失败
+ 3.快速失败（Fail fast）同时能快速恢复
+ 4.提供失败回退（Fallback）和优雅的服务降级机制
+ 5.提供近实时的监控、报警和运维控制手段

### Hystrix设计原则？

+ 1.防止单个依赖耗尽容器（例如 Tomcat）内所有用户线程
+ 2.降低系统负载，对无法及时处理的请求快速失败（fail fast）而不是排队
+ 3.提供失败回退，以在必要时让失效对用户透明化
+ 4.使用隔离机制（例如『舱壁』/『泳道』模式，熔断器模式等）降低依赖服务对整个系统的影响
+ 5.针对系统服务的度量、监控和报警，提供优化以满足近实时性的要求
+ 6.在 Hystrix 绝大部分需要动态调整配置并快速部署到所有应用方面，提供优化以满足快速恢复的要求
+ 7.能保护应用不受依赖服务的整个执行过程中失败的影响，而不仅仅是网络请求

### Hystrix怎样实现目标？

+ 1.在一个单独的线程中通过 HystrixCommand 或 HystrixObservableCommand 对象包装所有外部系统（或依赖）的调用。
+ 2.调用超时比设置的阈值更长。虽然有默认值，但是大多数依赖自己配置的这些超时“属性”，所以每个依赖都略高于实测性能的99.5%。
+ 3.为每个依赖保持一个小的线程池；如果线程池满了，新来的请求会立即拒绝掉，而不是排队等候。
+ 4.测试成功、失败（客户端抛出异常）、超时和线程拒绝。
+ 5.当请求失败、被拒、超时或者短路时的性能反馈逻辑。
+ 6.准实时的监控指标和配置改变。

### 开发文档

+ [入门文档](https://github.com/Netflix/Hystrix/wiki/Getting-Started)
+ [原理说明](https://github.com/Netflix/Hystrix/wiki/How-it-Works)
+ [使用说明](https://github.com/Netflix/Hystrix/wiki/How-To-Use)
+ [Javadoc](http://netflix.github.com/Hystrix/javadoc)
+ [开源地址](https://github.com/Netflix/Hystrix)